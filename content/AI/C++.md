
---
explicit 关键字的作用是什么？
#card <!--2024/3/3/VRM6x94-->
当构造函数被声明为 explicit 时，它不能用于隐式转换，即不能在需要类型转换的场合无声无息地将其他类型转换为这个类类型。这样可以避免不期望的类型转换，增强程序的类型安全和清晰性。

---
下面的代码可以通过编译吗？
```cpp
explicit Tensor(uint32_t size) : dims_(1), Tensor(1, 1, size) {}
```
#card <!--2024/3/3/V7WzGju-->
不可以，会报错：委托构造函数不能具有其他成员初始化表达式。
原因在于，为了保证初始化顺序。在C++中，成员变量的初始化顺序是按照它们在**类中声明的顺序**，而**不是它们在构造函数初始化列表中出现的顺序**。如果一个委托构造函数被允许有自己的成员初始化列表，那么可能会引发成员变量的**重复初始化**或者**初始化顺序的混乱**。

---
机器学习数据存储时，行主序和列主序的优缺点是什么？
#card <!--2024/3/3/IYx49V8-->

行主序和列主序是数据在内存中的存储方式，它们影响数据访问的局部性。
**行主序**优点：
- 适合按行访问数据，如深度学习。
- 在C/C++等语言中与内建数组布局一致。
**行主序**缺点：
- 按列访问数据时缓存性能差。
- 与数学、统计学库不一致。

Eigen库默认使用列主序（column-major order）。这意味着Eigen中的矩阵和数组在内存中以列为主要方向进行存储，即按列存储元素。这种存储方式与许多其他数学库和编程语言（如Fortran）的约定相一致。

---
对于下面的情况，  explicit 是必要的吗？

```cpp
explicit Tensor(const std::vector<uint32_t> shapes) {
    shapes_ = shapes;
  }
```

#card <!--2024/3/7/N0pTYkZ-->

在这种情况下，是否需要使用 `explicit` 取决于你对类设计的预期。 

如果你希望避免隐式类型转换，确保构造函数只能被显式调用，那么使用 `explicit` 是合适的。这样做可以防止意外的隐式类型转换，提高代码的安全性和可读性。例如，如果你不希望以下代码通过隐式类型转换来创建 `Tensor` 对象：

```cpp
std::vector<uint32_t> shapes = {1, 2, 3};
Tensor tensor = shapes;
```

那么你应该将构造函数声明为 `explicit`：

```cpp
explicit Tensor(const std::vector<uint32_t>& shapes) {
    shapes_ = shapes;
}
```

这样就需要显式地调用构造函数来创建 `Tensor` 对象：

```cpp
Tensor tensor({1, 2, 3}); // 显式调用构造函数
```

