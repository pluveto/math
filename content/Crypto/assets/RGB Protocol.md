## RGB

RGB 协议本质上是在比特币的 UTXO 里存一些交易相关的哈希（称为承诺），然后在客户端执行程序验证链上的这些摘要。RGB 声称实现了智能合约，但其实这种合约只是客户端执行的程序，这和 EVM 完全不同。

在 ETH 中，智能合约在所有的节点上执行，并且最终得到相同的结果，从而确保了合约的可靠。然而，也正是因为需要在所有节点执行，ETH 的智能合约部署成本很高，执行性能也很差。

RGB 协议认为，智能合约可以只在参与方之间执行，而不需要在所有的节点执行。数据在用户手里执行，用户也只能看到和自己有关的数据。这样解决了隐私问题，同时不会因为类似 ETH 的智能合约的控制者的问题导致用户受损失，不过也会导致一定程度阻碍其生态的繁荣。所以后来 v0.10 RGB 引入了全局状态。 

## 一次性密封 Single-Use-Seals

https://petertodd.org/2017/scalable-single-use-seal-asset-transfer

《通过一次性密封和发布证明实现可扩展的半信任资产转移》这篇文章由Peter Todd撰写，主要探讨了如何利用一次性密封（Single-Use-Seals）和发布证明（Proof-of-Publication）来实现资产的安全转移，特别是在区块链和加密货币的背景下。以下是文章的主要观点和结构概述：

### 定义

   - 一次性密封是一种抽象机制，用于防止双花（double-spends）。
   - 它支持两个基本操作：关闭和验证。
   - 关闭封条的操作（`Close(l, m) → w_l`）是将封条 `l` 关闭在消息 `m` 上，生成一个见证 `w_l`。
   - 验证封条的操作（`Verify(l, w_l, m) → bool`）是验证封条 `l` 是否已经关闭在消息 `m` 上。
   - 安全的封条实现要求不可能有两个不同的消息 `m1` 和 `m2` 对同一个封条进行验证并返回真。

在比特币的环境中，一个UTXO只能被消费一次。因此，比特币交易的输出可以被看作是一次性密封，而当这个输出被用作另一个交易的输入时，该密封就被“打破”或“使用”了。所以在 RGB 的语境，只要查询一个 UTXO 是否被花费就知道财产在这一环节是否被转移。

### 不可分割资产转移

   - 使用安全的一次性密封，可以构建一个不可分割资产转移系统。
   - 每个资产由其创世封条 `l0` 标识。
   - 转移资产时，最近的封条 `ln` 被关闭在一个新的封条 `l(n+1)` 上，生成一个见证 `w_ln`，证明该转移。
   - 通过验证从创世封条到最新封条的一系列见证和封条，接收者可以安全地验证他们收到了所需的代币。

### 可分割资产转移
   - 对于可分割资产，转移的是资产的数量而非单个独特的代币。
   - 使用“输出”概念，每个输出 `x` 都关联一个封条 `l` 和值 `v`。
   - 转移可分割资产定义了“花费”和“分割”的概念。
   - 花费 `D` 是对输出集 `xi .. xj` 的承诺；分割 `V` 是对零个或多个封条/值对的承诺。
   - 接收者可以通过生成新的封条，请求发送者创建新的分割输出，并验证新创建的分割输出的有效性来验证资产的安全转移。

## 总结

在实际中就是利用 UTXO 本身的机制实现防止双花。

## 客户端验证

客户端验证范式的核心思想是减少在分布式网络中需要验证状态转换的参与者的数量，从而提高效率。说人话，就是把合约放到用户电脑上算，数据可用性也交给客户端自己处理，分布式网络只负责提供所有权信息可用性（也即“出版证明”）。

### 对比

假设有一个分布式网络，其中多个节点需要进行数据交换和验证。在传统的区块链系统中，每一个新区块的生成和状态的改变都需要网络中的所有节点进行验证。这确保了整个网络的一致性，但同时也消耗了大量的计算资源。

在客户端验证的范式中，这个过程有所不同。设想这样一个场景：

1. 节点A想要将一笔交易发送给节点B。
2. 在传统的区块链系统中，这笔交易会被广播到整个网络，所有的节点都会验证交易的合法性，包括签名是否正确，发送者是否有足够的余额等。
3. 在客户端验证的范式中，节点A和节点B可以直接进行交易，并仅由这两个节点来验证交易的合法性。
4. 节点A使用一个加密哈希函数来创建一个代表这个交易的加密承诺（例如，一个哈希值）。
5. 这个加密承诺随后被发布到一个公开的「出版证明（Proof-of-Publication）」媒介中，比如一个区块链。
6. 通过这个加密承诺，任何想要验证交易有效性的第三方节点都可以在不需要了解交易所有细节的情况下，验证交易是否已经被节点A和节点B同意，并且已经被公开地记录在案。
7. 这个「出版证明」媒介同时还提供了收据证明、非发布证明、成员资格证明等功能，确保了交易的可验证性和不可否认性。

通过这种方式，只有交易的相关方需要进行详细的验证工作，而网络中的其他节点可以通过验证加密承诺来确认交易的状态，从而大大减少了整个网络需要执行的工作量。这种方法特别适合于那些不需要每个节点都存储和处理所有数据的去中心化应用。

OpenTimeStamps 协议就是基于这样的理念，它允许用户对数据进行时间戳标记，而不需要将数据本身存储在区块链上，只需要存储数据的哈希值，这样既保护了数据的隐私，又能够证明数据在特定时间点已经存在。

### RGB

RGB 协议的核心理念是，仅在必要的时候才调用比特币区块链，所有的代币转移的验证工作都从全局共识层中移除、放在链下，仅由接收支付的一方的客户端来验证。

假设艺术家 A 发行了数字资产 x，将 x 转移给 B、B 又转移给 C，RGB 如何确保这一过程正确执行：

在RGB协议中，艺术家A发行数字资产x的过程是通过创建一个智能合约来实现的，这个合约定义了资产的权利、分配给特定的比特币UTXO（未花费交易输出），并规定了所有权如何转移。以下是这个过程的简化描述：

1. **合约创建**：艺术家A首先使用RGB协议的模板（例如RGB20或RGB21）来创建一个智能合约。这个合约包含了资产的基本信息，如资产名称、发行数量、额外元数据等。合约还定义了哪些UTXO有权转移资产的所有权，并分配了其他权利（如增发权和重命名资产的权利）。

2. **资产发行**：艺术家A将资产x分配给特定的UTXO。这个过程不需要在比特币区块链上支付手续费，因为合约只是定义了资产的分配，而不是实际的资产转移。

3. **资产转移**：当B想要从A那里获得资产x时，A会通过一个比特币交易向B的UTXO转移资产的所有权。这个转移是通过在比特币区块链上发布一个承诺来实现的，而不是直接转移资产本身。这样，区块链上的观察者无法从交易中获取关于用户金融活动的具体信息。

4. **验证和执行**：B和C（如果C从B那里接收资产）可以验证他们收到的资产是否真实，通过阅读初始合约并验证所有权转移是否遵循了合约中的规则。这个过程是在客户端进行的，不需要全球网络的参与，从而提高了隐私性和可扩展性。

5. **点对点通信**：为了确保资产转移的正确性和防止审查，RGB协议建议使用点对点加密信道来传递所有权转移的证明。这样，A、B和C可以直接通信，而不需要通过中心化的服务。

6. **隐私和可扩展性**：RGB协议通过在客户端保存所有转让相关数据，确保了隐私性。同时，由于大部分数据都在链下处理，区块链仅用于保存承诺，这减少了手续费并提高了可扩展性。

通过这种方式，RGB协议确保了艺术家A发行的数字资产x在转移给B和C的过程中，每一步都按照合约的规则正确执行，同时保护了参与者的隐私和提高了系统的可扩展性。

### RGB 的资产转移过程

假设 Bob 想要给 Alice 转移资产。步骤如下：

1. Alice 需要构建一个 invoice，包含如下信息：合约 ID、状态转移参数、UTXO.
2. Bob 需要给出自己的资产的所有来龙去脉证明，也就是说从此资产从诞生到最后流转到 Bob 手上的整条证据，这个东西称为 consignment。
3. Alice 收到证明，验证之后，生成一个确认签名给 Bob。
4. Bob 将此交易的摘要信息发布到 BTC 网络。交易完成。


这个过程中，资产转移到谁手上，谁就要负责数据可用性，否则资产相当于永久遗失。

### 盲化

在密码学和隐私保护领域，盲化（Blinding）是一种技术，用于在进行计算或交互时隐藏敏感信息。它通过对数据进行变换或添加随机性来实现。

盲化的目的是防止参与方在处理数据时获取有关数据的具体信息，同时仍然能够进行必要的计算或交互。通过盲化，可以保护用户的隐私和数据的机密性。

## 源码浅析

### rgb-std

RGB-STD 标准库是一个用于实现RGB 协议的核心库。该库提供了一组功能，用于定义和处理数字资产的发行、转移和状态转换。

核心库（CORE LIB）提供了以下功能：

- `issue`：根据给定的模式（Schema）、元数据（Metadata）、全局状态（GlobalState）和分配（Assignments），生成初始状态（Genesis）。
 
标准库（STD LIB）提供了以下功能：

- `import`：将资产（Stash）和模式（Schema）或接口（Interface）导入到资产库（Stash）中。
- `state`：根据资产清单（Inventory）和合约ID（ContractId），获取合约的当前状态（ContractState）。
- `interpret`：根据合约状态（ContractState）和接口（Interface），解释合约的状态，生成解释后的状态（InterpretedState）。

标准库还提供了以下用于资产转移的功能：

- `issue`：根据给定的模式（Schema）、状态（State）和接口（Interface），调用`core::issue`函数生成资产转移的证明（Consignment）。
- `extract`：根据资产清单（Inventory）、合约ID（ContractId）和接口（Interface），生成资产转移的证明（Consignment），用于合约转移。
- `compose`：根据资产清单（Inventory）、合约ID（ContractId）、接口（Interface）和输出点（Outpoint）列表，生成资产转移的证明（Consignment），用于描述已存在的状态。
- `transfer`：根据资产转移的证明（Consignment）和其他参数，准备资产转移的状态转换（StateTransition）。
- `preserve`：根据资产库（Stash）、输出点（Outpoint）列表和状态转换（StateTransition），创建空白的状态转换（StateTransition）。
- `consign`：根据资产库（Stash）和状态转换（StateTransition），提取历史数据，生成资产转移的证明（Consignment）。

其他功能包括`reveal`、`validate`、`enclose`和`consume`，用于处理资产转移和合约的验证、封装和消耗。

钱包库（WALLET LIB）提供了以下功能：

- `embed`：将合约信息嵌入到部分签名交易（PSBT）中，以便在交易中添加合约信息。
- `commit`：将转换信息添加到部分签名交易（PSBT）中，以便在交易中添加转换信息。
- `bundle`：将多个单独的转换合并为一个部分签名交易（PSBT）。
- `finalize`：由BP（Blockchain Provider）执行的操作，将单独的承诺（commitments）转换为最终的交易。

总体而言，RGB-STD标准库提供了一组功能丰富的工具，用于定义和处理数字资产的发行、转移和状态转换，并为钱包开发人员提供了方便的功能，以便在交易中嵌入合约信息和转换信息。

### src/invoice.rs

整体介绍：
- 该库用于处理 RGB（RGB-20）协议的钱包操作，RGB 是一种构建在比特币和闪电网络之上的资产发行和管理协议。
- 该库提供了与 RGB 协议相关的数据结构和函数，用于创建和处理 RGB 发票（Invoice）。

关键概念和数据结构：
- `RgbTransport`：表示 RGB 传输方式的枚举类型，包括 JSON-RPC、REST HTTP、WebSockets 等。
- `InvoiceState`：表示发票的状态，可以是空（Void）、金额（Amount）、非同质化资产（Data）或附加标识符（Attach）。
- `ChainNet`：表示链网络的枚举类型，包括比特币主网（BitcoinMainnet）、比特币测试网（BitcoinTestnet）、Liquid 主网（LiquidMainnet）等。
- `XChainNet`：表示带有链网络信息的泛型类型，用于将数据与特定的链网络关联起来。
- `Beneficiary`：表示受益人的枚举类型，可以是盲签名（BlindedSeal）或见证输出（WitnessVout）。
- `RgbInvoice`：表示 RGB 发票的结构体，包含了传输方式、合约、接口、操作、受益人、发票状态、过期时间等信息。

盲签名（BlindedSeal）和见证输出（WitnessVout）是与 RGB 发票中的受益人（Beneficiary）相关的概念。

1. 盲签名（BlindedSeal）：
盲签名是一种密码学技术，用于在不暴露原始数据的情况下对数据进行签名。在 RGB 发票中，盲签名作为受益人的一种类型，表示受益人使用盲签名作为验证方式。盲签名可以保护受益人的隐私，因为在签名过程中，受益人的身份和数据是被隐藏的。

2. 见证输出（WitnessVout）：
见证输出是比特币中的一种特殊输出类型，用于存储与交易验证相关的数据。在 RGB 发票中，见证输出作为受益人的一种类型，表示受益人使用见证输出作为验证方式。通过使用见证输出，受益人可以提供与交易验证相关的证据，以证明其在交易中的权益。

这两种受益人类型（盲签名和见证输出）提供了不同的验证方式，用于确保 RGB 发票的安全性和可信度。具体使用哪种类型取决于发票的设计和需求。

关键函数：
- `ChainNet::layer1()`：根据链网络返回相应的 Layer1 类型（Bitcoin 或 Liquid）。
- `ChainNet::is_prod()`：判断链网络是否为生产环境。
- `ChainNet::address_network()`：根据链网络返回相应的地址网络类型。
- `XChainNet::with()`：根据给定的链网络和数据创建 XChainNet 类型的实例。
- `XChainNet::bitcoin()`：根据给定的网络类型和数据创建 XChainNet 类型的实例。
- `XChainNet::chain_network()`：获取 XChainNet 实例的链网络类型。
- `XChainNet::into_inner()`：获取 XChainNet 实例中的数据。
- `RgbInvoice::chain_network()`：获取 RGB 发票的链网络类型。
- `RgbInvoice::address_network()`：获取 RGB 发票的地址网络类型。
- `RgbInvoice::layer1()`：获取 RGB 发票的 Layer1 类型。
- `RgbInvoice::is_prod()`：判断 RGB 发票是否为生产环境。

